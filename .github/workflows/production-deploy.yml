name: Production Deployment

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      force_tests:
        description: 'Force running tests even in production'
        required: false
        default: false
        type: boolean
      skip_health_check:
        description: 'Skip post-deployment health checks'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18'
  NPM_CACHE_KEY: npm-${{ hashFiles('**/package-lock.json') }}

jobs:
  # Pre-deployment validation
  validate:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
      deploy-required: ${{ steps.check-changes.outputs.deploy-required }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Fetch last 2 commits for change detection
      
      - name: Determine deployment environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi
      
      - name: Check for relevant changes
        id: check-changes
        run: |
          if git diff --name-only HEAD^ HEAD | grep -E '\.(ts|tsx|js|jsx|css|html|json|md)$|^(src/|public/|scripts/|\.github/)'; then
            echo "deploy-required=true" >> $GITHUB_OUTPUT
            echo "✅ Changes detected that require deployment"
          else
            echo "deploy-required=false" >> $GITHUB_OUTPUT
            echo "ℹ️ No deployment-relevant changes detected"
          fi
      
      - name: Validate environment configuration
        run: |
          case "${{ steps.determine-env.outputs.environment }}" in
            production)
              if [[ -z "${{ secrets.PROD_API_BASE_URL }}" ]]; then
                echo "❌ Missing PROD_API_BASE_URL secret"
                exit 1
              fi
              ;;
            staging)
              if [[ -z "${{ secrets.STAGING_API_BASE_URL }}" ]]; then
                echo "❌ Missing STAGING_API_BASE_URL secret"
                exit 1
              fi
              ;;
          esac
          echo "✅ Environment configuration validated"

  # Security and quality checks
  security-scan:
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.deploy-required == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run security audit
        run: |
          # Check for known vulnerabilities
          npm audit --audit-level=high
          
          # Check for outdated dependencies with security issues
          npx npm-check-updates --target semver
      
      - name: Run dependency check
        run: |
          # Check for suspicious packages
          npx audit-ci --config .auditci.json || echo "⚠️ Audit warnings found"
          
          # Verify package integrity
          npm ls --depth=0
      
      - name: SAST scan with CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript
      
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

  # Build and test
  build-and-test:
    runs-on: ubuntu-latest
    needs: [validate, security-scan]
    if: needs.validate.outputs.deploy-required == 'true'
    
    strategy:
      matrix:
        test-type: [unit, e2e]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Cache build dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.npm
            node_modules/.cache
          key: ${{ runner.os }}-build-${{ env.NPM_CACHE_KEY }}
          restore-keys: |
            ${{ runner.os }}-build-
      
      - name: Run linter
        if: matrix.test-type == 'unit'
        run: npm run lint
      
      - name: Run type checker
        if: matrix.test-type == 'unit'
        run: npm run type-check
      
      - name: Run unit tests
        if: matrix.test-type == 'unit'
        run: |
          npm test -- --run --coverage --reporter=verbose
        env:
          VITEST_COVERAGE_REPORTER: json,html,text-summary
      
      - name: Upload unit test coverage
        if: matrix.test-type == 'unit'
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/coverage-final.json
          flags: unittests
          name: codecov-umbrella
      
      - name: Install Playwright browsers
        if: matrix.test-type == 'e2e'
        run: npx playwright install --with-deps
      
      - name: Run E2E tests
        if: matrix.test-type == 'e2e'
        run: npx playwright test
        env:
          PLAYWRIGHT_BASE_URL: http://localhost:5173
      
      - name: Upload E2E test results
        if: matrix.test-type == 'e2e' && always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 7
      
      - name: Build application
        if: matrix.test-type == 'unit'
        run: npm run build
        env:
          VITE_API_BASE_URL: ${{ secrets[format('{0}_API_BASE_URL', upper(needs.validate.outputs.environment))] }}
          VITE_WS_BASE_URL: ${{ secrets[format('{0}_WS_BASE_URL', upper(needs.validate.outputs.environment))] }}
          VITE_ENVIRONMENT: ${{ needs.validate.outputs.environment }}
          VITE_APP_VERSION: ${{ github.sha }}
          VITE_BUILD_TIME: ${{ github.event.head_commit.timestamp }}
      
      - name: Upload build artifacts
        if: matrix.test-type == 'unit'
        uses: actions/upload-artifact@v3
        with:
          name: build-files
          path: dist/
          retention-days: 1

  # Production deployment
  deploy-production:
    runs-on: ubuntu-latest
    needs: [validate, security-scan, build-and-test]
    if: |
      needs.validate.outputs.deploy-required == 'true' &&
      needs.validate.outputs.environment == 'production'
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: build-files
          path: dist/
      
      - name: Configure AWS credentials
        if: contains(secrets.DEPLOYMENT_METHOD, 'aws')
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Deploy to S3 and CloudFront
        if: contains(secrets.DEPLOYMENT_METHOD, 'aws')
        run: |
          # Upload to S3
          aws s3 sync dist/ s3://${{ secrets.S3_BUCKET_NAME }} \
            --delete \
            --cache-control "public,max-age=31536000,immutable" \
            --exclude "*.html" \
            --exclude "*.json"
          
          # Upload HTML with no-cache
          aws s3 sync dist/ s3://${{ secrets.S3_BUCKET_NAME }} \
            --cache-control "no-cache,no-store,must-revalidate" \
            --exclude "*" \
            --include "*.html" \
            --include "*.json"
          
          # Invalidate CloudFront cache
          aws cloudfront create-invalidation \
            --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*"
      
      - name: Deploy via SSH
        if: contains(secrets.DEPLOYMENT_METHOD, 'ssh')
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_SSH_PORT || 22 }}
          script: |
            # Create deployment directory
            sudo mkdir -p /tmp/spoton-deployment
            cd /tmp/spoton-deployment
            
            # Download artifacts (this is a simplified example)
            # In practice, you'd transfer the build files here
            
            # Run deployment script
            sudo VITE_API_BASE_URL="${{ secrets.PROD_API_BASE_URL }}" \
                 VITE_WS_BASE_URL="${{ secrets.PROD_WS_BASE_URL }}" \
                 VITE_ENVIRONMENT="production" \
                 HEALTH_CHECK_URL="${{ secrets.PROD_HEALTH_CHECK_URL }}" \
                 WEB_SERVER_SERVICE="nginx" \
                 /opt/spoton/scripts/deploy.sh
      
      - name: Run health checks
        if: github.event.inputs.skip_health_check != 'true'
        run: |
          HEALTH_URL="${{ secrets.PROD_HEALTH_CHECK_URL }}"
          if [[ -n "$HEALTH_URL" ]]; then
            echo "Running health checks against: $HEALTH_URL"
            
            # Wait for application to be ready
            for i in {1..12}; do
              if curl -f -s "$HEALTH_URL" > /dev/null; then
                echo "✅ Health check passed on attempt $i"
                break
              elif [[ $i -eq 12 ]]; then
                echo "❌ Health checks failed after 12 attempts"
                exit 1
              else
                echo "⏳ Health check attempt $i failed, retrying in 10 seconds..."
                sleep 10
              fi
            done
            
            # Detailed health check
            curl -s "$HEALTH_URL" | jq '.' || echo "Health check response received"
          else
            echo "ℹ️ No health check URL configured"
          fi
      
      - name: Performance audit
        run: |
          # Use Lighthouse CI for performance testing
          npm install -g @lhci/cli
          
          lhci autorun \
            --upload.target=temporary-public-storage \
            --collect.url="${{ secrets.PROD_HEALTH_CHECK_URL }}" \
            --collect.numberOfRuns=3 \
            --assert.preset=lighthouse:recommended || echo "⚠️ Performance audit completed with warnings"

  # Staging deployment
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [validate, security-scan, build-and-test]
    if: |
      needs.validate.outputs.deploy-required == 'true' &&
      needs.validate.outputs.environment == 'staging'
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: build-files
          path: dist/
      
      - name: Deploy to staging
        run: |
          echo "Deploying to staging environment..."
          # Add staging-specific deployment logic here
          # This could be similar to production but with different secrets

  # Post-deployment notifications and monitoring
  post-deployment:
    runs-on: ubuntu-latest
    needs: [validate, deploy-production, deploy-staging]
    if: always() && needs.validate.outputs.deploy-required == 'true'
    
    steps:
      - name: Determine deployment result
        id: deployment-result
        run: |
          PROD_RESULT="${{ needs.deploy-production.result }}"
          STAGING_RESULT="${{ needs.deploy-staging.result }}"
          
          if [[ "$PROD_RESULT" == "success" ]] || [[ "$STAGING_RESULT" == "success" ]]; then
            echo "result=success" >> $GITHUB_OUTPUT
            echo "status=✅ Deployment successful" >> $GITHUB_OUTPUT
          elif [[ "$PROD_RESULT" == "failure" ]] || [[ "$STAGING_RESULT" == "failure" ]]; then
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "status=❌ Deployment failed" >> $GITHUB_OUTPUT
          else
            echo "result=skipped" >> $GITHUB_OUTPUT
            echo "status=ℹ️ Deployment skipped" >> $GITHUB_OUTPUT
          fi
      
      - name: Send Slack notification
        if: always() && secrets.SLACK_WEBHOOK_URL
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ steps.deployment-result.outputs.result }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
          custom_payload: |
            {
              "channel": "#deployments",
              "username": "GitHub Actions",
              "icon_emoji": ":rocket:",
              "attachments": [
                {
                  "color": "${{ steps.deployment-result.outputs.result == 'success' && 'good' || steps.deployment-result.outputs.result == 'failure' && 'danger' || 'warning' }}",
                  "title": "SpotOn Frontend Deployment",
                  "fields": [
                    {
                      "title": "Status",
                      "value": "${{ steps.deployment-result.outputs.status }}",
                      "short": true
                    },
                    {
                      "title": "Environment",
                      "value": "${{ needs.validate.outputs.environment }}",
                      "short": true
                    },
                    {
                      "title": "Branch",
                      "value": "${{ github.ref_name }}",
                      "short": true
                    },
                    {
                      "title": "Commit",
                      "value": "<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>",
                      "short": true
                    },
                    {
                      "title": "Author",
                      "value": "${{ github.actor }}",
                      "short": true
                    },
                    {
                      "title": "Workflow",
                      "value": "<https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Details>",
                      "short": true
                    }
                  ],
                  "footer": "SpotOn Deployment Bot",
                  "ts": ${{ github.event.head_commit.timestamp && 'new Date("${{ github.event.head_commit.timestamp }}").getTime() / 1000' || 'Math.floor(Date.now() / 1000)' }}
                }
              ]
            }
      
      - name: Create deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const sha = context.sha;
            const environment = '${{ needs.validate.outputs.environment }}';
            const state = '${{ steps.deployment-result.outputs.result }}' === 'success' ? 'success' : 'failure';
            
            await github.rest.repos.createDeploymentStatus({
              owner,
              repo,
              deployment_id: context.payload.deployment?.id || 0,
              state,
              environment_url: environment === 'production' 
                ? '${{ secrets.PROD_HEALTH_CHECK_URL }}' 
                : '${{ secrets.STAGING_HEALTH_CHECK_URL }}',
              description: `Deployment ${state} for ${environment}`,
            });
      
      - name: Update monitoring dashboards
        if: steps.deployment-result.outputs.result == 'success'
        run: |
          # Send deployment markers to monitoring systems
          # This helps correlate deployments with metrics changes
          
          # DataDog deployment event (example)
          if [[ -n "${{ secrets.DATADOG_API_KEY }}" ]]; then
            curl -X POST "https://api.datadoghq.com/api/v1/events" \
              -H "Content-Type: application/json" \
              -H "DD-API-KEY: ${{ secrets.DATADOG_API_KEY }}" \
              -d '{
                "title": "SpotOn Frontend Deployment",
                "text": "Deployed commit ${{ github.sha }} to ${{ needs.validate.outputs.environment }}",
                "tags": ["environment:${{ needs.validate.outputs.environment }}", "service:spoton-frontend"],
                "alert_type": "info"
              }'
          fi
          
          # New Relic deployment marker (example)
          if [[ -n "${{ secrets.NEW_RELIC_API_KEY }}" ]]; then
            curl -X POST "https://api.newrelic.com/v2/applications/${{ secrets.NEW_RELIC_APP_ID }}/deployments.json" \
              -H "Content-Type: application/json" \
              -H "X-Api-Key: ${{ secrets.NEW_RELIC_API_KEY }}" \
              -d '{
                "deployment": {
                  "revision": "${{ github.sha }}",
                  "changelog": "${{ github.event.head_commit.message }}",
                  "description": "Automated deployment from GitHub Actions",
                  "user": "${{ github.actor }}"
                }
              }'
          fi

# Cleanup job
  cleanup:
    runs-on: ubuntu-latest
    needs: [post-deployment]
    if: always()
    
    steps:
      - name: Cleanup artifacts
        uses: actions/github-script@v7
        with:
          script: |
            // Clean up old artifacts to save storage
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId,
            });
            
            // Delete build artifacts after successful deployment
            for (const artifact of artifacts.data.artifacts) {
              if (artifact.name === 'build-files') {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                });
              }
            }